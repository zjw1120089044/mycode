<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面向对象</title>
    
</head>
<body>
    <button>按钮</button>


<script>
    class Student {
        //构造函数，接收传递的参数，在new生成实例时自动调用，不写也会自动生成
        constructor(uname, age) {
            this.uname = uname;
            this.age = age;
        }

        sing(song) {
            console.log("唱歌");
            console.log("歌名：" + song);
        }
    }

    var wei = new Student("伟", 22);
    console.log(wei.uname);
    console.log(wei);
    wei.sing("歌曲");


    // 继承
    class Father {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        money() {
            console.log("￥100");
        }
        sum() {
            console.log(this.x + this.y);
        }
        say() {
            console.log("父类");
        }
    }
    class Son extends Father {
        constructor(x, y) {
            super(x, y);  //子类不能直接调用父类中的构造函数，需要加super()
        }
        say() {
            console.log("子类");
            super.say();  //同样可用super在方法中调用父类的方法
        }
    }

    var myson = new Son(2, 3);
    myson.money();  //父类中的方法会自动继承

    myson.sum();

    myson.say();  //子类中与父类同名的方法，会优先调用子类
    
    myson.getNum = function(){   //给对象单独添加私有方法(添加在构造函数中)
        console.log('num');
    }
    myson.getNum();

    // ES6中没有变量提升，必须先定义类才能实例化对象
    class Person {
        constructor(uname, age) {
            this.uname = uname;
            this.age = age;
            // this指向通过new创建的实例对象

            this.btn = document.querySelector('button');
            this.btn.onclick = this.sayhi;   //不能加（），（）会导致函数直接被调用
                            // 这里的this指向调用者btn
        }

        sayhi() {
            console.log(this);
            console.log(this.uname); //this指向调用方法的对象
        }
    }

    var p1 = new Person("p1的名字");
    // p1.sayhi();
</script>
</body>
</html>
